#!/usr/bin/env python3
import argparse
import csv
import json
import os
import re
import statistics
import sys
from typing import List


def _read_cpu_csv(path: str) -> List[float]:
    values: List[float] = []
    with open(path, newline="", encoding="utf-8") as handle:
        reader = csv.DictReader(handle)
        for row in reader:
            raw = (row.get("pkg_cpu_percent") or "").strip()
            try:
                values.append(float(raw))
            except ValueError:
                values.append(0.0)
    return values


def _p95(values: List[float]) -> float:
    if not values:
        return 0.0
    sorted_values = sorted(values)
    index = int(round(0.95 * (len(sorted_values) - 1)))
    return sorted_values[index]


def _max_consecutive(values: List[float], threshold: float) -> int:
    best = 0
    current = 0
    for value in values:
        if value > threshold:
            current += 1
            best = max(best, current)
        else:
            current = 0
    return best


def _count_log_churn(path: str, pkg: str) -> int:
    if not os.path.exists(path):
        return 0

    patterns = [
        r"onPlaybackStateChanged\(\):\s*" + re.escape(pkg),
        r"onPlaybackStateChanged\(\):\s*" + re.escape(pkg) + r"\s+tried to update with no new data",
        r"NOTHING_DIAG\|playback\|",
    ]

    count = 0
    with open(path, encoding="utf-8", errors="ignore") as handle:
        for line in handle:
            if any(re.search(pattern, line) for pattern in patterns):
                count += 1
    return count


def _contains_active_wakelock(path: str, pkg: str) -> bool:
    if not os.path.exists(path):
        return False
    with open(path, encoding="utf-8", errors="ignore") as handle:
        data = handle.read()

    # Look for active partial wake lock lines, not historical wake lock log.
    active_pattern = re.compile(
        r"PARTIAL_WAKE_LOCK[^\n]*?(?:" + re.escape(pkg) + r"|com\.ryanheise\.audioservice\.AudioService)",
        re.IGNORECASE,
    )
    return bool(active_pattern.search(data))


def main() -> int:
    parser = argparse.ArgumentParser(description="Evaluate emulator power regression capture")
    parser.add_argument("capture_dir", help="Path to capture folder generated by emulator_power_regression.sh")
    parser.add_argument("--pkg", default="com.saplin.nothingness", help="Package name")
    parser.add_argument("--strict", action="store_true", help="Fail process on threshold violations")
    args = parser.parse_args()

    capture_dir = args.capture_dir
    cpu_s0_path = os.path.join(capture_dir, "cpu_s0.csv")
    cpu_s1_path = os.path.join(capture_dir, "cpu_s1.csv")
    logcat_path = os.path.join(capture_dir, "logcat_s1.txt")
    power_path = os.path.join(capture_dir, "dumpsys_power.txt")

    if not os.path.exists(cpu_s0_path) or not os.path.exists(cpu_s1_path):
        print("Missing cpu_s0.csv or cpu_s1.csv", file=sys.stderr)
        return 2

    cpu_s0 = _read_cpu_csv(cpu_s0_path)
    cpu_s1 = _read_cpu_csv(cpu_s1_path)

    s0_median = statistics.median(cpu_s0) if cpu_s0 else 0.0
    s1_median = statistics.median(cpu_s1) if cpu_s1 else 0.0
    s1_p95 = _p95(cpu_s1)
    s1_max_consecutive_high = _max_consecutive(cpu_s1, threshold=4.0)
    churn_count = _count_log_churn(logcat_path, args.pkg)
    has_active_wakelock = _contains_active_wakelock(power_path, args.pkg)

    delta = s1_median - s0_median

    violations = []

    if delta > 0.8 and s1_median > 0.8:
        violations.append(
            f"Idle background CPU regression: median delta={delta:.2f} (s0={s0_median:.2f}, s1={s1_median:.2f})"
        )

    if s1_p95 > 2.5:
        violations.append(f"High idle background CPU p95={s1_p95:.2f} (>2.5)")

    if s1_max_consecutive_high >= 3:
        violations.append(
            f"Sustained high CPU: {s1_max_consecutive_high} consecutive samples >4.0%"
        )

    if churn_count > 10:
        violations.append(f"Playback churn signature too high in logcat ({churn_count} lines)")

    # Keep wakelock as warning-level signal; foreground service config may intentionally hold one.
    warnings = []
    if has_active_wakelock:
        warnings.append("Active partial wakelock detected for app/audio service")

    summary = {
        "capture_dir": capture_dir,
        "pkg": args.pkg,
        "samples_s0": len(cpu_s0),
        "samples_s1": len(cpu_s1),
        "s0_median": round(s0_median, 3),
        "s1_median": round(s1_median, 3),
        "median_delta": round(delta, 3),
        "s1_p95": round(s1_p95, 3),
        "s1_max_consecutive_gt4": s1_max_consecutive_high,
        "log_churn_count": churn_count,
        "active_wakelock": has_active_wakelock,
        "warnings": warnings,
        "violations": violations,
        "status": "fail" if violations else "pass",
    }

    summary_path = os.path.join(capture_dir, "summary.json")
    with open(summary_path, "w", encoding="utf-8") as handle:
        json.dump(summary, handle, indent=2)

    print(json.dumps(summary, indent=2))

    if violations and args.strict:
        return 1
    return 0


if __name__ == "__main__":
    raise SystemExit(main())